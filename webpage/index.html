<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- HTML and style adapted from http://people.ece.cornell.edu/land/courses/ece4760/FinalProjects/f2014/skg73_wfh42/skg73_wfh42/  to match the Cornell ECE webpage layout -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta http-equiv="Content-Language" content="en-us">
<title>ECE 4760 RGB LED Matrix Clock</title>
<link rel="stylesheet" type="text/css" media="all" href="./cornell_main.css">
<link rel="stylesheet" type="text/css" media="all" href="./cornell_1column.css">
<link rel="stylesheet" type="text/css" media="all" href="./main.css">
<link rel="shortcut icon" href="./assets/favicon.ico" type="image/x-icon">
<meta name="author" content="Sam Miller, Craig Andres">
<meta name="copyright" content="Copyright (c) 2015 Sam Miller, Craig Andres"
<meta name="description" content="A fun and useful full featured RGB LED wall clock ready for many customizations.">
<meta name="keywords" content="KEYWORDS HERE">
</head>
<body>
<div id="header">
  <!-- The following div contains the Cornell University logo and search link -->
  <div id="cu-identity">
		<div id="cu-logo">
      <a href="http://www.ece.cornell.edu/"><img src="./assets/cu_logo.gif" alt="Cornell University" width="340" height="75" border="0"></a>
		</div>
  </div>
  <div class="linklist"> <a name="top"></a> </div>
  <!-- The search-form div contains a form that allows the user to search
		either pages or people within cornell.edu directly from the banner.	-->
  <div id="search-form">
    <form action="http://www.cornell.edu/search/" method="get" enctype="application/x-www-form-urlencoded">
      <div id="search-input">
        <label for="search-form-query">SEARCH:</label>
        <input type="text" id="search-form-query" name="q" value="" size="20">
        <input type="submit" id="search-form-submit" name="submit" value="go">
      </div>
      <div id="search-filters">
        <input type="radio" id="search-filters1" name="tab" value="" checked="checked">
        <label for="search-filters1">Pages</label>
        <input type="radio" id="search-filters2" name="tab" value="people">
        <label for="search-filters2">People</label>
        <a href="http://www.cornell.edu/search/">more options</a> </div>
    </form>
  </div>
</div>
<div id="mainnav">
  <ul>
    <li><a href="#design">High&nbsp;Level&nbsp;Design</a></li>
    <li><a href="#hardware">Hardware</a></li>
    <li><a href="#software">Software</a></li>
    <li><a href="#results">Results</a></li>
    <li><a href="#conclusions">Conclusions</a></li>
    <li><a href="#appendices">Appendices</a></li>
  </ul>
</div>
<!-- end mainnav -->
<!-- end header -->
<div id="sectiontitle">
  <div style="float:left;" id="sectiontitletext">
  <h4><a href="http://people.ece.cornell.edu/land/courses/ece4760/">ECE 4760</a>: <a href="http://people.ece.cornell.edu/land/courses/ece4760/FinalProjects/">Final Project</a></h4>
  <h1>A RGB LED Matrix Clock</h1>
  <h2>with IR Remote and Serial Interface</h2>
  <h3>Sam Miller (<a href="mailto:sgm82@cornell.edu">sgm82<!--REMOVE-->@<!--REMOVE-->cornell.edu</a>)</h3>
  <h3>Craig Andres (<a href="mailto:cra64@cornell.edu">cra64<!--REMOVE-->@<!--REMOVE-->cornell.edu</a>)</h3>
  </div>
  <div style="float:right; margin-top: 16px; margin-right: 16px;" id="sectiontitleimage">
    <img src="./assets/matrix_dtime.jpg" alt="Cornell University" width="150" height="150" border="0">
  </div>
</div>
<div id="wrapper">
	<div id="content">
		<div id="maincontent" class="hub">

		<div id="introblurb">

		<h2>Introduction &nbsp;&nbsp;&nbsp;<font size="-1"><strong><a href="#top">top</a></strong></font></h2>
		<p> In today's world of rushed schedules, time is something a ton of people are in constant need of keeping track of. A very good method for keeping track of the time is to have a wall clock. But what if you want a clock that's different from all the others, or something that will stand out and make your friends say "Hey, that's pretty awesome!" That's precisely what we set out to make when we undertook this project. Using the PIC32MX250F128B microcontroller, we built a wall clock that is made from a 32x32 LED Matrix. The clock comes with an IR remote that can control a variety of customization options and smaller features such as a stopwatch and alarm. It also has a serial channel that can connect to a PC to update the time to match your PC internet synced time.
		</p>
		<p>This project was completed over a five-week period for the ECE 4760: Designing with Microcontrollers class under Professor Bruce Land.
		</p>

    <div class="image">
      <a href="./assets/matrix_analog_lg.gif"><img src="./assets/matrix_analog_lg.gif" /></a>
      <p class="caption">One minute of the clocks analog display from the final result of the project.</p>
    </div>

          <div class="linklist"> <a name="design"></a>
            <h2>High Level Design &nbsp;&nbsp;&nbsp;<font size="-1"><strong><a href="#top">top</a></strong></font></h2>
            <h3>Overview</h3>
            <p>Our project runs off of a PIC32MX250F128B microcontroller, which handles all the controls and processing of data for the 32x32 LED Matrix. An Oscillator crystal handles the realtime-keeping component of the clock, and an IR reciever handles the input from our IR Remote Controller. We also have a serial connection to a PC so we can update the time to match the internet-regulated standards that most PCs sync with on a daily basis. All of these components come together to create the LED Matrix Clock we have designed, and we will go into more detail on these below.</p>


            <h4>Rationale</h4>
            <p>The idea for this project arose from the growing popularity of home appliances being both programmable and connected to the internet. As technology continues to evolve and become cheaper, more and more homes and buildings are incorporating these appliances that can be controlled through the internet, such as the Nest home heating unit and the Phillips Hue lighting system. We believe that this LED clock would be a great addition to a home that utilizes internet connected components. The our display could provide a central status hub that reports the status of various other components in the house as well add to a modern technological atmosphere.</p>

            <p>While we did not accomplish the ambitious goal of creating an internet connected centralized display this semester, we did build a self contained and novel device that works as functional clock. This is the first step in creating a more useful display and as will be discussed later on, hopefully the start of an on going project to add upon this clock that will make it go above and beyond the exciting wall clock.</p>

            <h4>Standards</h4>
            <p>Our project does not (as of this time) utilize RF communications or other regulated technologies, and therefore we could not find any pertinent standards to reference. We had anticipated finding standards for infrared remote technology but again, while we did find some standards used by various companies, we did not find any widely adopted standards that would be relevant to include with our project.</p>
            <h4>Relation to Existing Works</h4>
            <p>This project can and should be seen as very similar to the many LED Matrix displays. There are tons of creative LED Matrix projects of every kind, however, they are almost all done by hobbyists who either do not actively share any code or are completely opensource. Additionally, the vast majority of these hobbyist projects are done using the Arduino or more powerful systems such as a Raspberry Pi or FPGA, the former being very easy to work with and the later being highly performant for larger displays. At the onset of this project we were unable to find any documented projects using both the PIC32 architecture and a 32x32 RGB LED matrix. Everything we have done, excluding the resources referred to below, has been our own invention, inspired by our own interests and our peers' ideas.</p>

            <h4>Hardware and Software Trade-offs</h4>
            <p>Our project relies heavily on software. One major trade-off we had to decided between hardware and software was for the time keeping. We ran into an issue with the Pic32 RTCC module running too fast. It ended up being an issue of capacitance affecting the crystal (an affect of working on a breadboard we suspect). However, at that time we decided to try and use the UART serial interface to power all time keeping ability. In other words, a computer with a serial connection would send time updates over UART every second (or faster) in order for our system to update the display. We discovered that this is possible (we managed to get very good accuracy using this method). In the end though, once we fix the oscillator issue, we decided to use the pic32's RTCC unit instead. The benefits of this being that the system is now less coupled to a serial tether to a computer. Relying on software on the computer to send the time updates meant that if you turned off your computer, software on either the computer or the microcontroller failed, or a serial device lost connection the clock would stop telling time. Meanwhile, the computer clock is typically internet synced and always accurate but the major reliability issues spurred us to pick the best of both worlds where the RTCC is used to keep time but it confirms the time with the computer periodically if a serial connection is present.</p>
            <h4>High Level Block Diagram</h4>
			
            <p>The block diagram below shows how the various components of our project interact with each other on the highest level. The Python Application handles the syncronization of time with the PC's system time, but all data from the PC is eventually fed back to the PIC32 to be processed.</p>
			<div class="image">
				<a href="./assets/high_level.png"><img src="./assets/high_level.png" width="500" height="400"></a>
			</div>
            <h4>User Interface</h4>
            <p>The user interface for our project consisted of an Adafruit Mini IR Remote, which would control the clock's various functions based upon which button was pressed. Additionally, the serial interface would allow for the time to be manually set via a UART console. As the project stands now, the IR remote controls the toggling between the Digital and Analog views of the clock as well as between each of the various test images seen in the Results section below. Simply press the Left and Right arrow keys to change between the different views.</p>
			<p>Ideally, we would have used the IR Remote to control a menu interface that would come up on the LED Matrix, but due to time constaints, this feature was not implemented. However, it would be very simple to add on to the current control system just by adding in additional command handlers for the various buttons on the remote. </p>


          </div>
      </div>
      <div class="linklist"> <a name="hardware"></a>
        <h2>Hardware &nbsp;&nbsp;&nbsp;<font size="-1"><strong><a href="#top">top</a></strong></font></h2>

        <h3>Hardware Overview</h3>

        <p>The hardware for this project included several components. The most notable component is the Adafruit 32x32 RGB LED matrix display. The construction of our final product revolved around getting all the hardware bundled together on the back of the matrix so that it could be hung on a wall or stood up on a surface. In addition to the matrix and its control components (displayed in the image below) we also used two IR remote units for remote control.</p>

    <div class="image">
      <a href="./assets/matrix_hardware_annotated.png"><img src="./assets/matrix_hardware_annotated.png" width=720/></a>
      <p class="caption">Back side of the matrix clock showing the various highlighted hardware components. <strong>Green</strong> The Microstick II housing the PIC32 microprocessor. <strong>Red</strong> The solderboard circuit for the realtime clock oscillator. <strong>Magenta</strong> The connection for the RGB LED matrix display. <strong>Yellow</strong> The serial to usb adaptor. <strong>Cyan</strong> The IR receiver mounted to be visible from the front of the matrix.</p>
    </div>
	<p> The circuitry can be broken down into each component used below. The schematics for the circuits can be found in the Schematics Appendex section. All Pin connections to the MCU are specified here in the table below. </p>
		<table style="width:100%">
			<tr>
				<th>Device</th>
				<th>Pin(s)</th>
				<th>MCU Pin(s)</th>
				<th>Function</th>
			</tr>
			<tr>
				<td>IR Reciever</td>
				<td>SIGNAL OUT</td>
				<td>13</td>
				<td>Input Capture 1</td>
			</tr>
			<tr>
				<td>32.768 kHz Oscillator</td>
				<td>SIGNAL OUT</td>
				<td>11</td>
				<td>SOSCI</td>
			</tr>
			<tr>
				<td>LED Matrix</td>
				<td>R1, G1, B1 (color data)</td>
				<td>4-6</td>
				<td>IO</td>
			</tr>
			<tr>
				<td>LED Matrix</td>
				<td>R2, G2, B2 (color data)</td>
				<td>16-18</td>
				<td>IO</td>
			</tr>
			<tr>
				<td>LED Matrix</td>
				<td>CLK (data clock)</td>
				<td>2</td>
				<td>IO</td>
			</tr>
			<tr>
				<td>LED Matrix</td>
				<td>LAT (data latch)</td>
				<td>3</td>
				<td>IO</td>
			</tr>
			<tr>
				<td>LED Matrix</td>
				<td>OE (output enable)</td>
				<td>3</td>
				<td>IO</td>
			</tr>
			<tr>
				<td>LED Matrix</td>
				<td>A, B, C, D (row select)</td>
				<td>7, 14, 25, 26</td>
				<td>IO</td>
			</tr>
			<tr>
				<td>UART</td>
				<td>TX</td>
				<td>22</td>
				<td>UART 2 Recieve</td>
			</tr>
			<tr>
				<td>UART</td>
				<td>RX</td>
				<td>21</td>
				<td>UART 2 Transmit</td>
			</tr>
		</table>

		<br>
        <h4>RGB Matrix</h4>

        <p>The RGB LED Matrix has a five part wire interface:</p>
        <ul>
          <li><strong>6 wire channel for writing two RGB LED values at a time </strong>- you can only write on or off for each of the red, green, blue values at each pixel</li>
          <li><strong>4 wire row selection </strong>- only two rows are on at a time these bits select which rows, the binary value 0 would turn on 0 and 16, 1 would be 1 and 17, etc.</li>
          <li><strong>A clock signal</strong> - indicates that the color values should be latched for the next pixel</li>
          <li><strong>A latch signal</strong> - indicates that we are done writing the selected row and the values should be latched and displayed</li>
          <li><strong>A output enable signal </strong>- indicates that the currently selected row should be on</li>
        </ul>



        <div class="floatingimagewrapperwide">
          <a href="./assets/remotes.jpg"><img src="./assets/remotes.jpg" width=278/></a>
          <p class="caption">Two different IR remote controls we used.</p>
        </div>

        <h4>IR Sensor</h4>

		<p> The IR circuit was relatively simple, requiring only the TSOP38238 IR Receiver Sensor and a 330 Ohm resistor to protect the PIC32 in case of a surge. The IR reciever simply outputs pulse signals on Pin 13, that we pick up in software as described in the Software section below. Additionally, we made it compatable with the Adafruit Mini IR Remote as well as a standard Apple Slideshow Remote.</p>
		<p> Having two remotes available to us allowed for some interesting ideas for some two-player games to be made, but we didn't have enough time nor resources to implement this. However, it was great for debugging purposes to have one for each group member!</p>



        <h4>Serial Connection</h4>
        <p>The serial to usb connector we used was the <a href="https://www.sparkfun.com/products/9716">Sparkfun FTDI Basic Breakout</a>. We use this chip due to its compact size and seperation from a USB cable so that we can use the clock without a serial tether and not have to manage the cable. The TX/RX is connected to the PIC32 microcontroller on pins 22 and 21, respectively with the appropriate PPS configuration selected on the microcontroller.</p>

        <h4>External Oscillator</h4>

		<p>The circuit for the External Oscillator manages the Real-Time clock for timekeeping whenever a connection to the PC is not present. This circuit was graciously donated to us by our classmate Udit Gupta. In short, it creates a 1 second pulse signal, which we use as a clock to handle our second-counting via the input on Pin 11.</p>



      </div>
      <div class="linklist"> <a name="software"></a>
        <h2>Software &nbsp;&nbsp;&nbsp;<font size="-1"><strong><a href="#top">top</a></strong></font></h2>

        <h3>Overview</h3>

        <p>The software is the largest part of our project and is almost more of a deliverable than the device itself. We spent a large amount of time creating a standalone library for the LED Matrix display as well as making the project as well broken into logical components as possible. The idea is that anyone can fork our <a href="https://github.com/sm11963/matrix-clock">GitHub Repository</a> and easily start customizing the system as they see fit. Towards that goal it was heavy priority to make the project as clean as possible and modular so that in order to changing the use of any component (display being drawn, serial use, rtcc use, IR input, or other) is very simple.</p>

        <p>The software breaks up into the following components: LED Matrix Control Library, IR Signal Decoding/Handling, Realtime Clock and Calendar, Serial Interface with PC, and the Python Time-Sync Application. Each part of the software works in unision with each other in an effiecent manner.</p>

        <h3>Controlling the Matrix</h3>
        <p>The most challenging part of this project was developing the control library for the <a href="https://www.adafruit.com/products/2026">Adafruit 32x32 RGB LED matrix</a>. The matrix itself does not come with any datasheets or product guides indicating how to control it. Fortunately, there are several helpful guides for how to use this matrix with the Arduino from <a href="">Sparkfun</a> and <a href="https://learn.adafruit.com/32x16-32x32-rgb-led-matrix/overview">Adafruit</a> as well as a description of the findings of what was found when the hardware was reverse engineered <a href="http://www.rayslogic.com/propeller/Programming/AdafruitRGB/AdafruitRGB.htm">on this page</a>. Additionally, there is an <a href="https://github.com/adafruit/RGB-matrix-Panel">Arduino library</a> written for this matrix. Even with all of these resources it was a challenge to get the display working well.</p>

        <h4>Matrix Display Library</h4>

        <p>The first step in porting the Adafruit arduino library for the PIC32 was figuring out exactly what the library does to drive the display. We did this by hooking up and Arduino an playing with the scope to see what the Arduino was outputting to the matrix. Thankfully the library also includes helpful comments to aid in understanding the reasoning behind much of the code. This is vitally necessary since much of the code is highly optimized in order for the many matrix control wires to be output at a fast enough rate to achieve acceptable visual quality and reduced CPU usage. In the code base this is all part of <a href="https://github.com/sm11963/matrix-clock/blob/master/MatrixClock.X/rgb_matrix.c">rgb_matrix.c/h</a>.</p>
        <p>Here I will give a brief overview of the LED Matrix control interface and the control library. Better documentation can likely be found at the resources above focused on this topic. Using the wires specified in the hardware section if you wanted to write data to display colors on only two rows of leds (0 and 16) here would be steps:</p>
        <ol>
          <li>Set the color channels for the colors you want for the first pixel (column) 0 (so channel one would be the pixel (0,0) and channel two would set pixel (0,16).</li>
          <li>Set the clock signal momentarily then clear, latching that color values.</li>
          <li>Repeat 1 &amp; 2 for each column from 0 to 31.</li>
          <li>Set the latch signal and the output enable high. This will latch the new RGB values to the led controllers and disable the output.</li>
          <li>Clear the latch and the output. This will re-enable the output with the new color values displayed.</li>
        </ol>

        <p>In order to get a wider color range (12 bit in this case) and display flicker free frames, the process of writing values to the matrix must be done on an accurate schedule as fast as possible. This means interrupts and a timer must be used to drive the display. In order to get 12-bit color from just setting LEDs on or off we use <a href="http://www.batsocks.co.uk/readme/art_bcm_1.htm">Binary Code Modulation</a>. So since we are doing the entire matrix update in an interrupt to achieve precise timing for binary coded modulation this means we have to be as quick as possible so that the CPU is not always updating the matrix and has time for other tasks such as actually drawing what to display. So to accomplish a very fast ISR there are some tricks that are used. The first is arranging the matrix buffer so that we can read a memory value and immediately write it to an output port without having to manipulate bits first. The second is to make use of the SET/CLEAR/TOGGLE registers for all of the PIC32 control registers which allow us to modify bits in ports without first reading them to maintain the other bit values. Unfortunately, this means there is some inflexibility in the control library such the control pins are mapped to indices in the matrix buffer and with the current scheme you can only use the pins that are setup for it. In further iterations, macros might be used in order to allow some flexibility in the pins chosen for the matrix color control Finally, we ensure that loop unrolling and optimizations are on so that the loops to write to the array are as efficient as possible and this was verified in disassembly. More about the actual timing considerations is discussed in the results section.</p>

        <p>With an ISR to write the values stored in a matrix buffer, we can now write values to this buffer and the matrix will display those values stored in the buffer. But since this buffer is being read very fast by the ISR and might not be updated quickly by the main program, you will actually see individual pixels change on the display as they are written by software. This affect is undesirable and to remedy it we use two display buffers. One called the back buffer and one called the forward buffer. We always write to the back buffer and read the current pixels to display from the forward buffer. When we want to update the image, we set a flag that is read by the ISR after finishing drawing the full matrix. The ISR swaps the buffers by simply swapping the pointers to them so it now begins drawing the updated buffer. This means that animations can be very smooth.</p>

        <h4>Matrix Graphics Library</h4>
        <p>The matrix display library only gives a few functions to write to the matrix, drawPixel and fillScreen. While powerful there is many things that we want to be standard and not have to think about as a programmer using the LED matrix display. Thankfully, there was also a library providing this for the Arduino and since these functions are more high level they were much easier to port over. Additionally, the <a href="http://people.ece.cornell.edu/land/courses/ece4760/PIC32/index_TFT_display.html">ECE4760 TFT display library</a> is actually another port of the Adafruit graphics library to standard C and the PIC32. Therefore after cleaning it up and adding a few additional features we were able to use this library to draw lines, shapes, and text to the display with easy to use functions.</p>
        <p>One of our additions to the graphic library was a new font class. We needed a smaller font in order to fit more information on the screen. Therefore, we found an <a href="http://robey.lag.net/2010/01/23/tiny-monospace-font.html">opensource 3x5 font class</a> and added it to the library. This required converting a BDF font file into a C data definition to be used by the microcontroller. To accomplish this we wrote a <a href="https://github.com/sm11963/matrix-clock/blob/master/bdf2hex/bdf2hex.py">python script</a> to take in the font definition file, parse it, and write out the hex code values that can be used as a C array definition the bitmap pixels to draw for each character. Additionally, we generalized the printing functionality such that adding new fonts will not be so difficult.</p>

        <h4>Matrix Library Demos</h4>

        <p>In addition to creating the drawing libraries, we also ported and added some of the matrix display tests. As mentioned we wanted to have a standalone library. Part of that is having tests to bootstrap any user of the library. The Adafruit tests we ported test shape drawing, color spectrum, and text. We also added some of our own to test rendering images and colorlevels.</p>

        <h4>Clock Graphics</h4>
        <p>Since we are building a wall clock system, we need to have the clock faces to display. We added a clock graphics library. This is essentially just a collection of functions that were used to create the two clock faces (digital and analog) we have created during this project but we fully intended to make it easy to swap and tune the clock faces to be customizable.</p>

        <h3>Handling IR Signals</h3>
        <p> To get the remote control working with our project, the idea was to be able to decode pulses sent from the remote, via an IR Receiver that would translate the signal into a digital signal. This digital signal would then be fed into the Microcontroller and decoded accordingly. Fortunately for us, the TSOP38238 IR Receiver Sensor came with a built-in differential OP-Amp, and so it would output the square pulses for us from the beginning. It was also tuned to 38 KHz, which was what our remote transmitted at. </p>
        <p> The Adafruit Mini Remote Control that we used uses the NEC IR encoding type for transferring the data of which button was pressed. The protocol is relatively straightforward and is explained with stellar detail over <a href="http://techdocs.altium.com/display/FPGA/NEC+Infrared+Transmission+Protocol">at this website</a>. </p>
        <p> The difficult part for us, was figuring out the optimal way of decoding these incoming pulses on the Microcontroller in a way that wouldn’t interfere with the large CPU demand of the LED Matrix code. Adafruit graciously included an Arduino tutorial on how they decoded their inputs <a href="https://learn.adafruit.com/ir-sensor"> here.</a> However, this tutorial wasn’t A) optimized for our PIC32, and B) ran the entire code within a loop that would interfere with our LED Matrix code.</p>
        <p> To this end, we decided to utilize the same ideas we used in the Lab 1 Capacitance Meter. We would make an ISR that would trigger pulse captures, and then when we were certain that an entire pulse was captured, we would decode it. To do this, we had to utilize an Input Capture on RB13 of the PIC32. The setup for this was just as it was in Lab 1, except we trigger the timer capture on every single edge (rising and falling), because for the initialization pulse, we need both the high and the low widths. Once I had captured all the pulse times, I would then store them in an array for decoding. The following image is from the beginning stages of my work with this. Basically, the values you see in the column marked “LOW” are the timer counts for when the signal pulse was low, “HIGH” when it was high. I had set the timer with a prescalar of 64 on a 40 MHz clock, so each count corresponds to about 1.6e-6 seconds. This is the raw timer counts data, and after messing around with it for a while, I determined the following threshold values for various pulses:</p>
        <div class="image">
          <img src="assets/ir_test.jpg" alt="IR Pulse Counts on TFT" height="420" width="280">
          <p class="caption">This test program shows all the timer counts for each pulse. The red numbers are the decoded values from each pulse based on the values below.</p>
        </div>
        <ul>
          <li>Initialization Pulse: HIGH 5550 – 5850 counts followed by LOW 2650 – 2950 counts</li>
          <li>Repeat Pulse: HIGH 5550 - 5850 counts followed by LOW 1250 – 1550 counts</li>
          <li>Logical 0 Pulse: After Initialization Pulse, LOW 200 – 500 counts</li>
          <li>Logical 1 Pulse: After Initialization Pulse, LOW 900 – 1200 counts</li>
        </ul>
        <p>These thresholds are much higher than probably what is needed, but it helps to allow for a large variation in the case of signal interference, especially whenever you use the remote from a distance.</p>
        <p>The red numbers are the decoded versions of the pulses to the right. The 52 corresponds to the Initialization Pulse. There was an anomaly with our remote in which the logical inverse of our address (0x00) was always (0xFC) instead of (0xFF). We worked around this by just ignoring the logical inverse portions of our signal in the final decoding stage.
    Once everything was decoded into 1s and 0s, it was easy to then just check that the incoming address was 0x00, and translate the 8-bit opcode to a string.</p>

        <h3>Realtime Clock and Calendar</h3>
        <p>The realtime clock and calender was very easy to setup after reading through the <a href="http://ww1.microchip.com/downloads/en/DeviceDoc/61125E.pdf">PIC32 documentation</a> and examples online. Using the plib.h functions all that needs to be done is call the corresponding RTCCOpen() function and the RTCC should initialize and be ready to provide the time. Now, this is using a very trivial setup, however. A better application would use a drift correction algorithm to calculate the errors of the 32.768KHz oscillator that drives the realtime clock. This will be discussed further in the results section.</p>

        <p>In addition to simply enabling and reading the values directly from the RTCC, we added a set of date/time functions in <a href="https://github.com/sm11963/matrix-clock/blob/master/MatrixClock.X/datetime.c">datetime.c</a> to ease using the dates and converting between the Binary Coded Decimal values provided by the hardware RTCC. This also includes helpers to convert to strings to display dates.</p>

        <h3>Serial Interface</h3>
        <p>The serial interface we added to communicate with and set the time on the PIC32 is very simple. We use the Cornell Protothreads UART functions to read and write from the UART in a nice threaded protocol. We did find, however, that using the PT library to send serial data was a bit cumbersome and as such added some very convenient wrapper macros to simplify the sending of data using the PT library (these are in the serial extensions file, <a href="https://github.com/sm11963/matrix-clock/blob/master/MatrixClock.X/serial_ext.h">serial_ext.h</a>). The actual communication interface over serial consists of four messages. The PIC32 will send a "gtd" message (get time date) to the computer when it needs a time update. If the computer is connected and listening, it should respond with a time and then a date message. The time message just consists of the format: </p><blockquote>"t &lt;hours&gt;:&lt;minutes&gt;:&lt;seconds&gt;"</blockquote><p> This corresponds to the human readable time that the PIC32 should update to. The date is the same idea but the message format is:</p>
        <blockquote>
          "d &lt;month&gt;/&lt;day of month&gt;/&lt;year&gt;-&lt;day of week&gt;"
        </blockquote>
        <p>The last message that can be sent is a "BAD CMD" from the PIC32 to the computer. This indicates that a message was received that did not match either the time or date pattern. Each of these messages must be terminated by a carriage return as a end delimiter. Without a carriage return the PIC32 will read until its buffer is full and then parse the input which will result in an invalid if the max buffer does not match the specified patterns. To parse the patterns a simple sscanf is used with an appropriate format string.<p>

        <h4>Python Time-Sync Application</h4>
        <p>In addition to the code on the PIC32, we also had to have an application running on the computer to receive and respond to time/date update requests from the MCU. We wrote a <a href="https://github.com/sm11963/matrix-clock/blob/master/py-time/pytime.py">simple application</a> in Python 3.5 using <a href="https://github.com/pyserial/pyserial">PySerial</a> as the serial communication library. The appication simply waits reading the serial input until it gets a "gtd" message at which point it sends both the time and date. We found that we had to manually add delays to the serial write methods in order to avoid overflowing the PIC32s input buffer. We found that typically unthrottled writes of more than 8 characters resulted in the PIC32 UART receive interface locking up. The ensure that this does not occur under normal operation, we modified the PT UART library to check the UART overrun bit and clear it to restart the UART receiving. We suspect that we were encountering this error more that typically because our large amount of time spent in the matrix display interrupt caused the receive fifo buffer to not get read as often as it would typically.</p>

      </div>
      <div class="linklist"> <a name="results"></a>
        <h2>Results &nbsp;&nbsp;&nbsp;<font size="-1"><strong><a href="#top">top</a></strong></font></h2>

        <div class="image">
          <img src="./assets/matrix_dtime.jpg" alt="RGB LED Matrix showing digital clock display." width=350 height=350>
          <img src="./assets/matrix_onwall.jpg" alt="RGB LED Matrix hanging on wall showing analog clock display." width=350 height=350>
          <p class="caption"><strong>Left:</strong> The RGB LED Matrix displaying the digital clock face. <strong>Right:</strong> Example of RGB LED Matrix hanging on a wall displaying the analog clock as it might be used. Note that we have covered the display with simple printer paper in order to reduce the brightness.</p>
        </div>
        <div class="image">
          <img src="./assets/matrix_colorwheel.jpg" alt="" width=350px height=350px>
          <img src="./assets/matrix_colorlevels.jpg" alt="" width=350px height=350px>
          <p class="caption"><strong>Left:</strong> The Matrix displaying a colorwheel demo (from referenced Adafruit library). <strong>Right:</strong> The Matrix displaying a demo of the 16 color intensities for each of the red, green, and blue LEDs. Note that in these images especially the cell phone camera captures a stripping effect which is not visible to the naked eye.</p>
        </div>

        <h3>Matrix Display</h3>
        <p>The matrix display results were excellent. Due to the PIC32's faster clock speed (running everything at 40MHz so room to improve further) and memory footprint, we were able to successfully control the matrix at a refresh rate near 450Hz using roughly 30% CPU. This is the CPU time that is required to just <em>update the matrix display</em>, it does not include any time to actually draw anything to be displayed. In order to measure the time in the ISR we added test code to toggle a bit when entering and exiting the ISR then measured the times on an oscilloscope. Since there are four different control flow paths and different spacings of the ISR we measured the ISR for four interrupts and the delay between. The whole period (which corresponds to drawing a single row) takes 137 microseconds and in that time we are in the ISR for 11.6 + 8.8 + 8.0 + 8.0 = 36.4 microseconds. So therefore we are spending 36.4 / 137 = 26.6% of CPU time handling the ISR for the matrix update. Now we have to do one of these updates for each row (16 rows since we write out two rows at a time) so in order draw the entire matrix once it takes 16*137 = 2192 microseconds. This corresponds to a refresh rate of 1/0.002192 = 456Hz. This may seem extremely high since humans it is above the typical frame rate at which humans can notice. However, due to the use of binary coded modulation to get the colors and only two rows of the matrix are lit at a time, this refresh rate is necessary to make the display appear non flickery and as smooth as it is.</p>

        <p>The display looks excellent visually for all colors and animations except on scenario. There is some issue with the red color input for the upper half of the matrix. When displaying bright red colors (high amount of red) in the upper half, we end of getting flickering of the red LEDs in the middle of the matrix. Experimenting with swapping ports and with other colors revealed that this is only an issue for the color red and only for the top half of the matrix. We hypothesize that it may be a voltage issue since the matrix is typically uses a logic level of 5V instead of the 3.3V of the PIC32, since we just discoved this issue recently we unfortunately, have not had the opportunity to swap in a logic level converter to see if it makes a difference but that is the next step.</p>


        <h3>IR Control</h3>
        
        <p>The IR Controllers worked fantastically as controls for the Matrix. Although we didn't get the menu interface in as we intended to, toggling from one view to another was as simple as a single button press. </p>
		<p>Using both remotes worked smoothly as expected as well. There were some observed differences between the two remotes that made us consider using one over the other in the future as well. The main observation was that the Adafruit Mini IR Remote was much weaker in its range than the Apple Remote. The Adafruit could only be detected at ranges less than about 5 meters, while the Apple Remote could work at ranges as long as the lab (which is at least 25 meters). However, the Apple Remote encountered some issues with interference with a classmate's MacBook laptop. Whenever buttons on the Apple Remote were pressed, occassionally PowerPoint would open on their computer. We knew that using the Apple Remote had the potential to interface with Apple computers, but usually a "pairing" in neccessary before the laptop will recognize this. The Adafruit Mini Remote did not have any interference issues with any other devices within the lab. Considering these factors, we decided it might be a better idea to only use the Adafruit Remote in the future, as it's low power and non-associtivity with existing devices give it lower chance of causing interference with other devices.</p>
		<p>The signal interference made an important point when considering which remote to use, which is also why our IR Decoding method always checks the signal address. Both of our remotes used address (0x00). To make sure we didn't decode other group's IR signals, we only would accept signals that transmitted with this data address as its target.</p>
        <h3>Serial Interface</h3>
        <p>The serial interface works wonderfully with the PIC32 after throttling send rates from the computer and checking the error bits. We now only send a character every 2 milliseconds but we only send 11 characters max with the time and 13 characters for the date. This results in a expected delay of about 22 milliseconds minimum for the time (which is more crucial since we are setting a realtime clock). It then may take additional time for the PT library to wake up the serial thread to actually process the message. We found that adding a second to the time before sending to the PIC32 generally improved the accuracy. We believe that determining the average time for the serial thread to process the message would be desirable but might be overkill since we do not require precise timing.</p>
        <p>As an aside, before we got the RTCC on the PIC32 operational, we were able to get the serial interface sending precisely timed updates to the PIC32 to maintain the time very well. This of course has drawbacks of being very coupled to the computer and more failure points but is a good fall back mode.</p>

        <h3>Realtime Clock and Calender</h3>
        <p>Our realtime clock and calender unit ended up being less accurate than desired. We did not get a chance to do precise measurements in the lab of the accuracy but we did a extrinsic test of the clock being used for a 48 hour period. For the first, 24 hours the clock started at perfectly in sync with computer time (truth value in this experiment) and was detached from the computer (no serial communication to update). We found that the time was approximately 14 seconds fast after that 24 hour period. This is a huge error of over a minute and half a week and unacceptable for the device we wanted to create. However, the second half the of the test consisted of 24 with the serial tether connected to a PC. For each checkup we made the time was perfectly in sync (as measured by the human eye). So in this case we cannot rely on the real time clock unit for any period of time greater than an hour (half a second loss estimate). We believe this error is caused by issues of packing the oscillator along with the other higher frequency control wires all in the back of the matrix unit, possibly causing interfere and disrupting the timing but without doing the proper testing with a oscilloscope it is hard to determine.</p>

      </div>
      <div class="linklist"> <a name="conclusions"></a>
        <h2>Conclusions &nbsp;&nbsp;&nbsp;<font size="-1"><strong><a href="#top">top</a></strong></font></h2>

        <h3>Summary</h3>
        <p>Our project did a lot of what we set out to do, but didn't meet 100% of our goals. We intended to have a menu interface that would be controllable via the IR remote that could be used to set Alarms as well. Other than that, though, all of our goals were met with excellent results. An entire control library for the 32x32 LED Matrix was written, including fonts, animations, and shape drawing. The time was kept in an accurate manner, it syncs with a PC's time, and is displayed in both Analog and Digital fashions. The IR Remote can be used to toggle between various images and the two time displays, with no issues at all. In our opinions, the project met almost everything of what we set out to do, with the groundwork set for much expansion in the future. We are very satisfied with the results, and hope to continue working on this project into the future.</p>

        <h4>Applicable Standards</h4>
        <p>Our project did not have any standards that applied to it. We personally did not want our IR devices to interfere with others, and so we decided to use the Adafruit Remote over the Apple Remote to nullify this issue.</p>

        <h4>Intellectual Property Considerations</h4>
          <p>We do utilize three libraries in our codebase which were written by others. The first is the Cornell <a href="http://people.ece.cornell.edu/land/courses/ece4760/PIC32/index_Protothreads.html">protothreading library</a>. Written by Bruce Land, this library contributes by adding a UART interface and threading system (adapted from the <a href="http://dunkels.com/adam/pt/">protothreads library</a> written by Adam Dunkels). We have also made modifications to this library to suit our appilication. The second library we used is the <a href="https://github.com/adafruit/RGB-matrix-Panel">Adafruit RGB Matrix Panel Library for Arduino</a>. We used this library as a means of testing and reverse engineering the interface for controlling the RGB matrix. Our our control library for the RGB matrix is heavily based on the concepts from the Adafruit library but re-written for the PIC32 architecture. Finally, we also adapted and added to the <a href="https://github.com/adafruit/Adafruit-GFX-Library">Adafruit GFX Library for Arduino</a>. We used an already adapted version of this library (adapted by Syed Tahmid Mahbub and can found at <a href="http://tahmidmc.blogspot.com/">his blog</a>). We adapted it further for the matrix as well as adding additional functions as necessary. All of these libraries are open source and have no restrictions on use provided proper referencing.</p>
          <p>We also use a bitmap font definition that is available for opensource use under the <a href="https://github.com/sm11963/matrix-clock/blob/master/bdf2hex/LICENSE.txt">MIT license</a> which we have included with our project as required.</p>

        <h4>Ethical Considerations</h4>
        <p>Throughout the entire period in which our project was performed, future and prior, all members of our team strictly followed the IEEE Code of Ethics. All decisions within the group were made with the safety of all members and welfare of the public put firstmost. No conflicts of interest were encounted during our project. All data and measurements stated on this page are truthful to the best of our knowledge. Even though no bribes presented themselves, no bribes were accepted, nor would they would have they been. All efforts in this project were intended to improve our group's understanding of technology, its appropriate application, and potential consequences. Before any movements were taken on the part of the group, thorough research and comprehension was performed to ensure that the project stood within any pertinent limitations. Technical critisim was welcomed and sought by all members in an effort to acknowledge, learn from, and correct errors. Addtionally, all members openly gave technical critism to those who sought it. All outside contributions to this project were properly accredited in the appropriate manner. No person was ever discriminated against for any reason based upon race, religion, gender, disability, age, national origin, sexual orientation, gender identity, or gender expression. No action from any of our members injured anyone, their property, reputation, or employment by false or malicoious action. Lastly, all members assisted colleagues and co-workers in a professional manner to provide helpful development and to support them in following the aforementioned IEEE Code of Ethics. Every possible action was taken to make this project safe, enjoyable, and rewarding for every entitiy involved.</p>

        <h4>Legal Considerations</h4>
        <p>To our knowledge, our device does not violate any legal regulations. Pulse transmissions from our two Remotes are from commercially avaiable devices, and are within the 38kHz range common with most commerical IR devices. Use of lab equipment was authorized with prior permission from the lab staff. </p>

      </div>
      <div class="linklist"> <a name="appendices"></a>
        <h2>Appendices &nbsp;&nbsp;&nbsp;<font size="-1"><strong><a href="#top">top</a></strong></font></h2>
        <h3>A. Parts List and Costs</h3>
        <table width="100%" border="1">
          <thead>
            <tr>
              <th><strong>Part</strong></th>
              <th><strong>Link</strong></th>
              <th><strong>Cost</strong></th>
            </tr>
          </thead>
          <tbody>
            <tr class="row1">
              <td>32x32 RGB LED Matrix</td>
              <td>https://www.adafruit.com/products/2026</td>
              <td>$45</td>
            </tr>
            <tr class="row2">
              <td>5V Power Supply</td>
              <td>https://www.adafruit.com/products/276</td>
              <td>$8</td>
            </tr>
            <tr class="row1">
              <td>Adafruit Mini IR Remote</td>
              <td>https://www.adafruit.com/products/389</td>
              <td>$5</td>
            </tr>
            <tr class="row2">
              <td>IR Receiver</td>
              <td>https://www.adafruit.com/products/157</td>
              <td>$2</td>
            </tr>
            <tr class="row1">
              <td>32.768 KHz Crystal</td>
              <td>https://www.adafruit.com/products/2211</td>
              <td>$0.75</td>
            </tr>
            <tr class="row2">
              <td>MicroStick II</td>
              <td></td>
              <td>$10</td>
            </tr>
            <tr class="row1">
              <td>White Protoboard</td>
              <td></td>
              <td>$6</td>
            </tr>
            <tr class="row2">
              <td>PIC32MX250F128B</td>
              <td></td>
              <td>$5</td>
            </tr>
            <tr class="row1">
              <td>14 Pin Socket</td>
              <td></td>
              <td>$0.70</td>
            </tr>
            <tr class="row2">
              <td>Small Solderboard</td>
              <td></td>
              <td>$1.00</td>
            </tr>
            <tr class="row1">
              <td>MM74C02N NOR Gate</td>
              <td>https://www.digikey.com/product-detail/en/MM74C02N/MM74C02N-ND/3158</td>
              <td>$1.00</td>
            </tr>
            <tr class="row2">
              <td>USB to TTL Serial</td>
              <td>https://www.adafruit.com/products/954</td>
              <td>$10</td>
            </tr>
            <tr class="row1">
              <td>Mini USB Cable</td>
              <td>https://www.monoprice.com/Product?p_id=3896</td>
              <td>$0.74</td>
            </tr>
            <tr class="row2">
              <td>Mounting brackets</td>
              <td></td>
              <td>$3.00</td>
            </tr>
            <tr class="row1">
              <td>3 Resistors</td>
              <td></td>
              <td>$0.30</td>
            </tr>
            <tr class="row2">
              <td>10 pF Capacitors</td>
              <td></td>
              <td>$1.00</td>
            </tr>
            <tr class="row1">
              <td><strong>Total</strong></td>
              <td></td>
              <td><strong>$99.49</strong></td>
            </tr>
          </tbody>
        </table>

        <h3>B. Source Code</h3>
        <p>Please browse, comment, and fork the code at our <a href="https://github.com/sm11963/matrix-clock">GitHub Repository</a>.</p>

        <h3>C. Schematics</h3>
			<table style="width:100%">
			<tr>
				<th>Device</th>
				<th>Pin(s)</th>
				<th>MCU Pin(s)</th>
				<th>Function</th>
			</tr>
			<tr>
				<td>IR Reciever</td>
				<td>SIGNAL OUT</td>
				<td>13</td>
				<td>Input Capture 1</td>
			</tr>
			<tr>
				<td>32.768 kHz Oscillator</td>
				<td>SIGNAL OUT</td>
				<td>11</td>
				<td>SOSCI</td>
			</tr>
			<tr>
				<td>LED Matrix</td>
				<td>R1, G1, B1 (color data)</td>
				<td>4-6</td>
				<td>IO</td>
			</tr>
			<tr>
				<td>LED Matrix</td>
				<td>R2, G2, B2 (color data)</td>
				<td>16-18</td>
				<td>IO</td>
			</tr>
			<tr>
				<td>LED Matrix</td>
				<td>CLK (data clock)</td>
				<td>2</td>
				<td>IO</td>
			</tr>
			<tr>
				<td>LED Matrix</td>
				<td>LAT (data latch)</td>
				<td>3</td>
				<td>IO</td>
			</tr>
			<tr>
				<td>LED Matrix</td>
				<td>OE (output enable)</td>
				<td>3</td>
				<td>IO</td>
			</tr>
			<tr>
				<td>LED Matrix</td>
				<td>A, B, C, D (row select)</td>
				<td>7, 14, 25, 26</td>
				<td>IO</td>
			</tr>
			<tr>
				<td>UART</td>
				<td>TX</td>
				<td>22</td>
				<td>UART 2 Recieve</td>
			</tr>
			<tr>
				<td>UART</td>
				<td>RX</td>
				<td>21</td>
				<td>UART 2 Transmit</td>
			</tr>
		</table>
        <div class="image">
			<a href="./assets/ir_circuit.png"><img src="./assets/ir_circuit.png" alt="Ir Circuit" height="400" width="500"></a>
			<p class="caption">IR Circuit. The first pin of the TSOP38238 is what outputs the incoming pulses from the remote, and it goes to our MCU. The second and third pins go to ground and 3.3Vdd respectively.</p>
		</div>
		<div class="image">
			<a href="./assets/oscillator_schematic.png"><img src="assets/oscillator_schematic.png" alt="Oscillator Schematic" height="400" width="400"></a>
			<p class="caption">Oscillator Circuit. The 32.768 kHz crystal creates pulses, which we then modify using the RC delays to create a 1 second time period.</p>
		</div>

        <h3>D. Division of Labor</h3>

        <ul>
          <li>Sam</li>
          <ul>
            <li>Handled all LED Matrix library rewriting</li>
			<li>Wrote Control program for LED Matrix</li>
			<li>Wrote all Time-Keeping program functions</li>
          </ul>
          <li>Craig</li>
          <ul>
            <li>Created the IR Circuit</li>
			<li>Obtained IR opcodes, handled all decoding of incoming IR signals</li>
          </ul>
		  <li>Both</li>
			<ul>
				<li>Created this website</li>
			</ul>
        </ul>

      </div>
      <div class="linklist"> <a name="references"></a>
        <h2>References &nbsp;&nbsp;&nbsp;<font size="-1"><strong><a href="#top">top</a></strong></font></h2>
        <p style="margin: 0 0 0.5em">The following lists (to the best of our ability) all the websites and resources that provided us with the information that made this project possible.</p>
        <div class="group1">
          <h3>Datasheets</h3>
          <ul>
            <li><a href="http://ww1.microchip.com/downloads/en/DeviceDoc/61125E.pdf">PIC32 RTCC</a></li>
			<li><a href="https://www.adafruit.com/datasheets/2026datasheet.pdf">32x32 LED Matrix</a></li>
			<li><a href="https://www.adafruit.com/datasheets/tsop382.pdf">TSOP38238 IR Reciever</a></li>
			<li><a href="https://www.adafruit.com/images/product-files/2211/2211datasheet.pdf">32.768 kHz Crystal</a></li>
          </ul>
        </div>
        <div class="group2">
          <h3>References</h3>
       
          <ul>
            <li><a href="https://github.com/adafruit/RGB-matrix-Panel">Adafruit RGB Matrix Arduino Library</a></li>
            <li><a href="https://github.com/adafruit/Adafruit-GFX-Library">Adafruit Graphics Arduino Library</a></li>
            <li><a href="https://learn.adafruit.com/32x16-32x32-rgb-led-matrix/overview">Adafruit LED Matrix Tutorial</a></li>
            <li><a href="https://learn.sparkfun.com/tutorials/rgb-panel-hookup-guide">Sparkfun LED Matrix Tutorial</a></li>
            <li><a href="https://learn.adafruit.com/32x16-32x32-rgb-led-matrix/overview">Adafruit LED Matrix Tutorial</a></li>
            <li><a href="http://people.ece.cornell.edu/land/courses/ece4760/PIC32/index_TFT_display.html">Cornell TFT Display Guide and Code</a></li>
            <li><a href="http://people.ece.cornell.edu/land/courses/ece4760/PIC32/index_Protothreads.html">Cornell Protothread Library</a></li>
            <li><a href="http://robey.lag.net/2010/01/23/tiny-monospace-font.html">3x5 Bitmap Font</a></li>
            <li><a href="https://github.com/pyserial/pyserial">PySerial</a></li>
			<li><a href="https://learn.adafruit.com/ir-sensor">Adafruit IR Sensor Tutorial</a></li>
			<li><a href="http://techdocs.altium.com/display/FPGA/NEC+Infrared+Transmission+Protocol">NEC Transmission Protocol</a></li>
			
          </ul>
        </div>
      </div>

      <div class="linklist"> <a name="ack"></a>
        <h2>Acknowledgements &nbsp;&nbsp;&nbsp;<font size="-1"><strong><a href="#top">top</a></strong></font></h2>

        <p>First and foremost, we thank Professor Bruce Land for teaching such an amazing class at Cornell University.</p>
        <p>We thank the lab TAs for making the class possible (especially Shiva for our lab section) and everyone else involved in making the ECE 4760 course a reality.</p>
        <p>We would also like to thank Udit Gupta for providing us with his own spare oscillator unit -- solving our troubles with using the onboard Pic32 RTCC module.</p>
      </div>
    </div><!-- end maincontent -->
  </div><!-- end content -->
</div><!-- end wrapper -->

<div id="footerwrap">
  <div id="footer">
    <div id="copyright">
      <div class="copyright">Website template adapted from Sahil Gutpta &amp; Forrest Henderson with permission</div>
      <div class="copyright">Layout &copy;2014 Cornell University</div>
    </div>
  </div>
</div>

</body>
</html>
